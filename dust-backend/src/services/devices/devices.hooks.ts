import { HookContext } from '@feathersjs/feathers';
import { resolveData, hooks as schemaHooks } from '@feathersjs/schema'
import { debug, disallow } from 'feathers-hooks-common';

import {
  deviceDataValidator,
  nanoIdDataResolver,
  timestampsDataResolver,
  devicePatchValidator,
  deviceQueryValidator,
  deviceResultResolver,
  deviceExternalResolver,
  deviceTypeGenericResolver,
  treeGenericResolver,
  deviceTypeIdDataResolver,
  deviceQueryResolver,
  deviceBeforeCreateCleanupDataResolver,
  deviceSensorsGenericResolver
} from './devices.schema'

export default {
  around: {
    all: [
      schemaHooks.resolveExternal(deviceExternalResolver), 
      schemaHooks.resolveResult(
        deviceTypeGenericResolver,    // Need the deviceType for returning the "devicetype" user friendly field
        deviceResultResolver
      ),
    ]
  },
  before: {
    all: [
      schemaHooks.validateQuery(deviceQueryValidator), 
      schemaHooks.resolveQuery(deviceQueryResolver)
    ],
    find: [],
    get: [],
    create: [
      schemaHooks.validateData(deviceDataValidator),        // 1. Validate the data coming from the user
      schemaHooks.resolveData(
        nanoIdDataResolver,             // 2. Inject a NanoID as _id
        deviceTypeGenericResolver,      // 3. Populate DeviceType association based on the user provided name
        treeGenericResolver,            // 4. Populate Tree association
        deviceTypeIdDataResolver,       // 5. Set the DeviceType ID based on the populated association
        timestampsDataResolver          // 6. Set timestamps
      ), 
      schemaHooks.resolveData(deviceBeforeCreateCleanupDataResolver), // 7. Cleanup the data before storing it in the database
      // 8. resolveResult providers are run next
      // 9. resolveExternal providers are run next
    ],
    patch: [
      disallow('external'),       // TODO - Fix the patching of external devices
      // schemaHooks.validateData(devicePatchValidator), 
      // schemaHooks.resolveData(devicePatchResolver)
    ],
    remove: []
  },
  after: {
    all: [],
    create: [
      schemaHooks.resolveData(deviceSensorsGenericResolver),    // 1. Populate list of devicesensors that belong to this specific device.
      debug('Time to create the sensors for the device !!!!!!!!!!!!!!!!!!!!!!!!!!!!'),

      // TODO - Here we need to create the sensors for the device
    ]
  },
  error: {
    all: []
  }
};




// export async function create_sensors_for_device(context : HookContext) {

//   // Next we need to build sensors based on these devicesensor "descriptions"
//   const sensors: Array<Sensor> = devicesensors.map(ds => {
//     return {
//       // _id and id are generated by the service
//       name: ds.sensortype.name,
//       device_id: context.result._id.toString(),      // context.result contains the device for which we are creating sensors
//       sensortype_id: ds.sensortype_id.toString(),
//       meta: ds.meta,
//       data_source: {
//         source: ds.data_source.source,
//         bucket: ds.data_source.bucket,
//         measurement: ds.data_source.measurement,
//         // TODO - change any-type to correct type...
//         tags: Object.keys(ds.data_source.tags).reduce((newObj: any, tag) => { newObj[tag] = context.result.datasource_key; return newObj; }, {}),
//         field: ds.data_source.field
//       }
//     }
//   });

//   // Last we need to create all these new sensors
//   await Promise.all(sensors.map(async (sensor) => {
//     await context.app.service('sensors').create(sensor);      // Don't pass params unless you remove the `provider` prop so it's not seen as external request
//   }));

//   return context;
// }