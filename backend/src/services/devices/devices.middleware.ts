import { HookContext } from '@feathersjs/feathers';
import { fastJoin } from 'feathers-hooks-common';
import { Device } from '../../types/device';
import { Sensor } from '../../types/sensor';
import { DeviceSensor } from '../../types/devicesensor';

// Resolvers are used by fastJoin to populate child object relations
export const device_resolvers = {
  joins: {
    // Can't use get() in joins below because we do not join on _id
    tree_by_nanoid: () => async (device : any, context: HookContext) => device.tree = (await context.app.service('trees').find({
      query: { id: device.tree_id, $limit: 1 },
      paginate: false
    }))[0],   // TODO - What if this fails ?

    devicetype: () => async (device : any, context: HookContext) => device.type = (await context.app.service('devicetypes').find({
      query: { type: device.devicetype, $limit: 1 },
      paginate: false
    }))[0],   // TODO - What if this fails ?

    devicetype_by_id: () => async (device : any, context: HookContext) => device.type = (await context.app.service('devicetypes').find({
      query: { id: device.devicetype_id, $limit: 1 },
      paginate: false
    }))[0],   // TODO - What if this fails ?

    // TODO - Refactor to get() but we probable need to force mongo id
    tree_by_mongoid: () => async (device : any, context: HookContext) => device.tree = (await context.app.service('trees').find({
      query: { _id: device.tree_id, $limit: 1 },
      paginate: false
    }))[0],   // TODO - What if this fails ?
  }
};

export const join_tree_with_device_by_nanoid = fastJoin(device_resolvers, { tree_by_nanoid: true });
export const join_tree_with_device_by_mongoid = fastJoin(device_resolvers, { tree_by_mongoid: true });
export const join_devicetype_with_device = fastJoin(device_resolvers, { devicetype: true });
export const join_devicetype_with_device_by_typeid = fastJoin(device_resolvers, { devicetype_by_id: true });

export async function build_device(context : HookContext) {
  const device : Device = {
    name: context.data.name,
    description: context.data.description,
    devicetype_id: context.data.type._id,
    tree_id: context.data.tree._id,
    datasource_key: context.data.datasource_key
  }
  context.data = device
  return context
}

export async function create_sensors_for_device(context : HookContext) {
  // First we need a list of devicesensors that belong to this specific device.
  const devicesensors: Array<DeviceSensor> = await context.app.service('devicesensors').find({
    query: { devicetype_id: context.result.devicetype_id },
    paginate: false
  });

  // Next we need to build sensors based on these devicesensor "descriptions"
  const sensors: Array<Sensor> = devicesensors.map(ds => {
    return {
      // _id and id are generated by the service
      name: ds.sensortype.name,
      device_id: context.result._id.toString(),      // context.result contains the device for which we are creating sensors
      sensortype_id: ds.sensortype_id.toString(),
      meta: ds.meta,
      data_source: {
        source: ds.data_source.source,
        bucket: ds.data_source.bucket,
        measurement: ds.data_source.measurement,
        // TODO - change any-type to correct type...
        tags: Object.keys(ds.data_source.tags).reduce((newObj: any, tag) => { newObj[tag] = context.result.datasource_key; return newObj; }, {}),
        field: ds.data_source.field
      }
    }
  });

  // Last we need to create all these new sensors
  await Promise.all(sensors.map(async (sensor) => {
    await context.app.service('sensors').create(sensor);      // Don't pass params unless you remove the `provider` prop so it's not seen as external request
  }));

  return context;
}

export async function sanitize_create_device(context : HookContext) {
  context.dispatch = {
    id: context.result.id,
    name: context.result.name,
    description: context.result.description,
    tree_id: context.result.tree.id,
    devicetype: context.result.type.type,
    datasource_key: context.result.datasource_key
  }
  // context.dispatch.original = context.result;    // For testing/debugging
  return context
}
